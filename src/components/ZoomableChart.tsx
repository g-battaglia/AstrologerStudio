'use client'

import { useCallback, useEffect, useMemo, useRef, useState } from 'react'
import clsx from 'clsx'
import { Button } from '@/components/ui/button'

/**
 * Props describing the chart markup and optional behaviour tuning.
 * @property html Raw HTML generated by the astrology engine (typically an SVG string).
 * @property className Optional styling forwarded to the outer container.
 * @property minScale Smallest zoom level permitted when the user zooms out.
 * @property maxScale Largest zoom level permitted when the user zooms in.
 */
type ZoomableChartProps = {
  html: string
  className?: string
  minScale?: number
  maxScale?: number
}

// Semantic constants for zoom and comparison thresholds
const DEFAULT_MIN_SCALE = 0.75
const DEFAULT_MAX_SCALE = 5
const DEFAULT_SCALE = 1
const WHEEL_ZOOM_FACTOR = 1.1
const BUTTON_ZOOM_FACTOR = 1.2
const SCALE_COMPARISON_THRESHOLD = 0.001
const TRANSLATION_COMPARISON_THRESHOLD = 0.5
const PAN_ENABLED_SCALE_THRESHOLD = 1.05 // Pan only enabled when zoomed in past this threshold

/**
 * Keep a numeric value within the provided range.
 */
const clamp = (value: number, min: number, max: number): number => {
  if (value < min) return min
  if (value > max) return max
  return value
}

/**
 * Calculate the distance between two touch points so we can detect pinch deltas.
 */
const getDistance = (touchA: Touch, touchB: Touch): number => {
  const deltaX = touchA.clientX - touchB.clientX
  const deltaY = touchA.clientY - touchB.clientY
  return Math.hypot(deltaX, deltaY)
}

/**
 * Basic validation to ensure the HTML content is safe and not empty.
 * This is a basic check; the actual HTML should be sanitized server-side.
 */
const isValidHtml = (html: string): boolean => {
  return typeof html === 'string' && html.trim().length > 0
}

/**
 * Interactive container that renders chart markup and adds wheel, pinch and drag gestures.
 * - `html` should be trusted markup (server rendered SVG) that will be injected verbatim.
 * - Zoom can be controlled by wheel, pinch, or the +/- controls.
 * - Panning uses pointer events so both mouse drag and touch drag work.
 */
export function ZoomableChart({
  html,
  className,
  minScale = DEFAULT_MIN_SCALE,
  maxScale = DEFAULT_MAX_SCALE,
}: ZoomableChartProps) {
  // DOM refs used for event wiring and to read layout boxes during gestures.
  const containerRef = useRef<HTMLDivElement | null>(null)
  const contentRef = useRef<HTMLDivElement | null>(null)
  // Live transform state: zoom, transform origin, and panning offset.
  const [scale, setScale] = useState(DEFAULT_SCALE)
  const scaleRef = useRef(scale)
  const [translation, setTranslation] = useState({ x: 0, y: 0 })
  const translationRef = useRef(translation)

  // Track live transform values during gestures (for smooth 60fps without React re-renders)
  const liveTransformRef = useRef({ scale: DEFAULT_SCALE, x: 0, y: 0 })

  /**
   * Return the chart to its original size and location and clear any active pointer captures.
   */
  const resetView = useCallback(() => {
    setScale(DEFAULT_SCALE)
    setTranslation({ x: 0, y: 0 })
  }, [])

  // Any time the incoming markup changes we want to drop accumulated transforms.
  useEffect(() => {
    resetView()
  }, [html, resetView])

  // Keep synchronous references to the latest values so event handlers can read them.
  useEffect(() => {
    translationRef.current = translation
    liveTransformRef.current.x = translation.x
    liveTransformRef.current.y = translation.y
  }, [translation])

  useEffect(() => {
    scaleRef.current = scale
    liveTransformRef.current.scale = scale
  }, [scale])

  // Apply transform directly to DOM element for smooth 60fps during gestures
  const applyTransform = useCallback(() => {
    const content = contentRef.current
    if (!content) return
    const { scale: s, x, y } = liveTransformRef.current
    content.style.transform = `translate(${x}px, ${y}px) scale(${s})`
  }, [])

  // Handle wheel-based zooming and pinch/pan touch gestures on the chart container.
  useEffect(() => {
    const container = containerRef.current
    const content = contentRef.current

    if (!container || !content) {
      return
    }

    // Gesture state
    let lastTouchDistance: number | null = null
    let singleTouchStart: { x: number; y: number; translationX: number; translationY: number } | null = null
    let mouseStart: { x: number; y: number; translationX: number; translationY: number } | null = null
    let isGestureActive = false

    // Helper to calculate new scale/translation focusing on a point
    const zoomToPoint = (scaleFactor: number, clientX: number, clientY: number) => {
      const { scale: currentScale, x: currentX, y: currentY } = liveTransformRef.current

      const newScale = clamp(currentScale * scaleFactor, minScale, maxScale)

      // Calculate cursor position relative to the content (0-1)
      // We need to account for the current transform
      // content X = currentX + relativeX * currentScale
      // relativeX = (clientX - rect.left) / currentScale <- NO, rect.left is already transformed

      // Correct math with 0,0 origin:
      // The point under cursor (relative to unscaled content) is:
      // P = (Cursor - Translation) / Scale
      // We want P to remain under Cursor after new Scale/Translation:
      // Cursor = NewTranslation + P * NewScale
      // NewTranslation = Cursor - P * NewScale
      // NewTranslation = Cursor - ((Cursor - Translation) / Scale) * NewScale

      // We need container-relative coordinates for calculations to be stable
      const containerRect = container.getBoundingClientRect()
      const cursorX = clientX - containerRect.left
      const cursorY = clientY - containerRect.top

      // Point in chart coordinates (unscaled)
      const pointX = (cursorX - currentX) / currentScale
      const pointY = (cursorY - currentY) / currentScale

      const newX = cursorX - pointX * newScale
      const newY = cursorY - pointY * newScale

      // Update live transform
      liveTransformRef.current = { scale: newScale, x: newX, y: newY }
      applyTransform()

      // Update touch-action immediately to avoid lag in gesture handling
      if (container) {
        container.style.touchAction = newScale > PAN_ENABLED_SCALE_THRESHOLD ? 'none' : 'manipulation'
      }

      // Sync state if this was a discrete action (wheel)
      return { newScale, newX, newY }
    }

    const handleWheel = (event: WheelEvent) => {
      event.preventDefault()
      const scaleFactor = event.deltaY < 0 ? WHEEL_ZOOM_FACTOR : 1 / WHEEL_ZOOM_FACTOR
      const { newScale, newX, newY } = zoomToPoint(scaleFactor, event.clientX, event.clientY)
      setScale(newScale)
      setTranslation({ x: newX, y: newY })
    }

    // Helper to check if event target is an interactive element (buttons, etc)
    const isInteractiveElement = (target: EventTarget | null) => {
      return target instanceof Element && target.closest('[data-zoom-interactive], button, a, [role="button"]')
    }

    const handleTouchStart = (event: TouchEvent) => {
      // Don't intercept touches on UI controls
      if (isInteractiveElement(event.target)) return

      if (event.touches.length === 2) {
        const touch0 = event.touches[0]
        const touch1 = event.touches[1]
        if (!touch0 || !touch1) return
        lastTouchDistance = getDistance(touch0, touch1)
        singleTouchStart = null
        isGestureActive = true
        event.preventDefault()
        event.stopPropagation()
      } else if (event.touches.length === 1) {
        const currentScale = liveTransformRef.current.scale
        if (currentScale > PAN_ENABLED_SCALE_THRESHOLD) {
          const touch = event.touches[0]
          if (!touch) return
          singleTouchStart = {
            x: touch.clientX,
            y: touch.clientY,
            translationX: liveTransformRef.current.x,
            translationY: liveTransformRef.current.y,
          }
          isGestureActive = true
          // Directly ensure touch-action is none to help browser tracking
          if (container) container.style.touchAction = 'none'

          // Only prevent default if we are actually capturing the drag for panning
          // This allows scroll to work if we are NOT zoomed in (logic handled by checks above)
          // However, here we ARE zoomed in, so we block scroll.
          event.preventDefault()
        }
        // If not zoomed, allows scroll (don't call preventDefault)
      }
    }

    const handleTouchMove = (event: TouchEvent) => {
      if (event.touches.length === 2 && lastTouchDistance !== null) {
        event.preventDefault()
        event.stopPropagation()
        singleTouchStart = null

        const touch0 = event.touches[0]
        const touch1 = event.touches[1]
        if (!touch0 || !touch1) return

        const currentDistance = getDistance(touch0, touch1)
        if (currentDistance === 0) return

        const distanceRatio = currentDistance / lastTouchDistance
        lastTouchDistance = currentDistance

        // Calculate midpoint for zoom origin
        const midpointX = (touch0.clientX + touch1.clientX) / 2
        const midpointY = (touch0.clientY + touch1.clientY) / 2

        zoomToPoint(distanceRatio, midpointX, midpointY)
        return
      }

      if (event.touches.length === 1 && singleTouchStart !== null) {
        event.preventDefault() // Always prevent default while handling custom pan
        const touch = event.touches[0]
        if (!touch) return

        const deltaX = touch.clientX - singleTouchStart.x
        const deltaY = touch.clientY - singleTouchStart.y

        const newX = singleTouchStart.translationX + deltaX
        const newY = singleTouchStart.translationY + deltaY

        // Calculate max allowed translation based on current scale
        const containerRect = container.getBoundingClientRect()
        const currentScale = liveTransformRef.current.scale
        // Calculate limits based on top-left origin (0,0)
        // Max translation is 0 (left/top aligned)
        // Min translation is container_size * (1 - scale) (right/bottom aligned)
        const minX = containerRect.width * (1 - currentScale)
        const maxX = 0
        const minY = containerRect.height * (1 - currentScale)
        const maxY = 0

        liveTransformRef.current.x = clamp(newX, minX, maxX)
        liveTransformRef.current.y = clamp(newY, minY, maxY)
        applyTransform()
      }
    }

    const handleTouchEnd = (event: TouchEvent) => {
      // Logic for transition from 2 fingers to 1 finger
      if (event.touches.length === 1 && lastTouchDistance !== null) {
        lastTouchDistance = null
        const currentScale = liveTransformRef.current.scale
        if (currentScale > PAN_ENABLED_SCALE_THRESHOLD) {
          const touch = event.touches[0]
          if (touch) {
            singleTouchStart = {
              x: touch.clientX,
              y: touch.clientY,
              translationX: liveTransformRef.current.x,
              translationY: liveTransformRef.current.y,
            }
          }
        }
        return
      }

      if (event.touches.length === 0) {
        lastTouchDistance = null
        singleTouchStart = null
        if (isGestureActive) {
          isGestureActive = false
          // Sync final state
          const { scale: s, x, y } = liveTransformRef.current
          setScale(s)

          // Ensure container touch-action is sync with final state
          // (React render will handle this eventually via isZoomedIn, but explicit set is safer)
          if (container) {
            container.style.touchAction = s > PAN_ENABLED_SCALE_THRESHOLD ? 'none' : 'manipulation'
          }

          setTranslation({ x, y })
        }
      }
    }

    // MOUSE EVENTS (Desktop Pan)
    const handleMouseDown = (event: MouseEvent) => {
      // Only left click and if zoomed in
      if (event.button !== 0) return

      // Allow interaction with UI controls
      if (isInteractiveElement(event.target)) return

      const currentScale = liveTransformRef.current.scale
      if (currentScale <= PAN_ENABLED_SCALE_THRESHOLD) return

      // Check if the click target is an interactive element (already handled by function above)
      // keeping check just for safety logic flow if refactored later
      if (isInteractiveElement(event.target)) return

      mouseStart = {
        x: event.clientX,
        y: event.clientY,
        translationX: liveTransformRef.current.x,
        translationY: liveTransformRef.current.y,
      }
      isGestureActive = true
      container.style.cursor = 'grabbing'
      event.preventDefault()
    }

    const handleMouseMove = (event: MouseEvent) => {
      if (!mouseStart) return
      event.preventDefault()

      const deltaX = event.clientX - mouseStart.x
      const deltaY = event.clientY - mouseStart.y

      const newX = mouseStart.translationX + deltaX
      const newY = mouseStart.translationY + deltaY

      // Calculate limits based on top-left origin (0,0)
      const containerRect = container.getBoundingClientRect()
      const currentScale = liveTransformRef.current.scale

      const minX = containerRect.width * (1 - currentScale)
      const maxX = 0
      const minY = containerRect.height * (1 - currentScale)
      const maxY = 0

      liveTransformRef.current.x = clamp(newX, minX, maxX)
      liveTransformRef.current.y = clamp(newY, minY, maxY)
      applyTransform()
    }

    const handleMouseUp = () => {
      if (mouseStart) {
        mouseStart = null
        isGestureActive = false
        container.style.cursor = ''
        // Sync state
        const { scale: s, x, y } = liveTransformRef.current
        setScale(s)
        setTranslation({ x, y })
      }
    }

    container.addEventListener('wheel', handleWheel, { passive: false })
    container.addEventListener('touchstart', handleTouchStart, { passive: false })
    container.addEventListener('touchmove', handleTouchMove, { passive: false })
    container.addEventListener('touchend', handleTouchEnd)
    container.addEventListener('touchcancel', handleTouchEnd)

    // Mouse listeners
    container.addEventListener('mousedown', handleMouseDown)
    window.addEventListener('mousemove', handleMouseMove)
    window.addEventListener('mouseup', handleMouseUp)

    return () => {
      container.removeEventListener('wheel', handleWheel)
      container.removeEventListener('touchstart', handleTouchStart)
      container.removeEventListener('touchmove', handleTouchMove)
      container.removeEventListener('touchend', handleTouchEnd)
      container.removeEventListener('touchcancel', handleTouchEnd)

      container.removeEventListener('mousedown', handleMouseDown)
      window.removeEventListener('mousemove', handleMouseMove)
      window.removeEventListener('mouseup', handleMouseUp)
    }
  }, [minScale, maxScale, applyTransform])

  // Determine whether the chart is perfectly reset so we can hide/show the reset button.
  const isDefaultView = useMemo(() => {
    const isDefaultScale = Math.abs(scale - DEFAULT_SCALE) < SCALE_COMPARISON_THRESHOLD
    const isDefaultX = Math.abs(translation.x) < TRANSLATION_COMPARISON_THRESHOLD
    const isDefaultY = Math.abs(translation.y) < TRANSLATION_COMPARISON_THRESHOLD
    // Float comparisons are fuzzy because transforms accumulate minor rounding errors.
    return isDefaultScale && isDefaultX && isDefaultY
  }, [scale, translation.x, translation.y])

  const isZoomedIn = scale > PAN_ENABLED_SCALE_THRESHOLD

  /**
   * Programmatic zoom controls (used by the +/- buttons).
   * The factor mirrors the 20% granularity commonly found in map applications.
   */
  const handleZoom = useCallback(
    (direction: 'in' | 'out') => {
      const factor = direction === 'in' ? BUTTON_ZOOM_FACTOR : 1 / BUTTON_ZOOM_FACTOR
      setScale((previous) => clamp(previous * factor, minScale, maxScale))
    },
    [maxScale, minScale],
  )

  // Validate HTML content
  if (!isValidHtml(html)) {
    return (
      <div className={clsx('flex items-center justify-center p-8 text-muted-foreground', className)}>
        <p>Invalid or empty chart data</p>
      </div>
    )
  }

  return (
    <div
      ref={containerRef}
      className={clsx(
        'select-none relative will-change-transform overflow-x-visible md:overflow-y-visible overflow-y-clip',
        // Initial state handled by CSS, dynamical updates by direct manipulation for perf
        isZoomedIn ? 'touch-none' : 'touch-manipulation',
        'cursor-grab', // Default cursor, grabbing is handled via style manipulation
        className,
      )}
      role="region"
      style={{ touchAction: isZoomedIn ? 'none' : 'manipulation' }} // Inline style as fallback base
      aria-label="Zoomable astrology chart"
    >
      {/* Floating controls: reset appears only when needed, zoom controls stay always available. */}
      <div
        className="absolute right-0 bottom-4 lg:bottom-auto lg:top-0 z-10 flex items-end lg:items-start gap-2"
        data-zoom-interactive
        role="toolbar"
        aria-label="Chart controls"
      >
        {!isDefaultView ? (
          <Button
            size="sm"
            variant="outline"
            className="shadow bg-background/80 backdrop-blur-sm hover:bg-background/90"
            onClick={resetView}
            aria-label="Reset chart view to default"
          >
            Reset view
          </Button>
        ) : null}
        <div
          className="flex h-8 items-stretch rounded-md border border-input bg-background/80 backdrop-blur-sm shadow"
          role="group"
          aria-label="Zoom controls"
        >
          <Button
            size="sm"
            variant="ghost"
            className="h-full rounded-none px-3 text-base first:rounded-l-md border-r border-input hover:bg-background/90"
            onClick={() => handleZoom('in')}
            aria-label="Zoom in"
            title="Zoom in (or use mouse wheel)"
          >
            +
          </Button>
          <Button
            size="sm"
            variant="ghost"
            className="h-full rounded-none px-3 text-base last:rounded-r-md hover:bg-background/90"
            onClick={() => handleZoom('out')}
            aria-label="Zoom out"
            title="Zoom out (or use mouse wheel)"
          >
            -
          </Button>
        </div>
      </div>
      <div
        ref={contentRef}
        className="w-full max-w-full origin-top-left md:overflow-y-visible"
        // We use inline styles for the initial render, but subsequent updates happen via direct DOM manipulation
        style={{
          transform: `translate(${translation.x}px, ${translation.y}px) scale(${scale})`,
          transformOrigin: '0 0', // Fixed origin, we handle the visual origin via translation math
        }}
        role="img"
        aria-label="Astrology chart visualization"
        dangerouslySetInnerHTML={{ __html: html }}
      />
    </div>
  )
}

export default ZoomableChart
